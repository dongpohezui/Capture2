/**


*/

#include "Capture2.h"

DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_UNLOAD Capture2DriverUnload;

EVT_WDF_DEVICE_FILE_CREATE EvFileCreate;
EVT_WDF_FILE_CLOSE EvFileClose;


//全局变量
Capture2_GLOBALS Globals;

VOID
Capture2DriverUnload(_In_ WDFDRIVER DriverObject)
/**
卸载驱动
*/
{
	DbgPrint("Capture2DriverUnload\n");

	if (Globals.InjectionHandle != NULL) {
		FwpsInjectionHandleDestroy(Globals.InjectionHandle);
	}

	Capture2UnregisterCallout();

	if(Globals.EngineHandle != NULL) {
		FwpmEngineClose(Globals.EngineHandle);
	}

	Globals.EngineHandle = NULL;

}


/*
NTSTATUS
Capture2InitDevice() {
	NTSTATUS Status;

}

*/


NTSTATUS
Capture2InitDriver(
    _Inout_ DRIVER_OBJECT* driverObject,
    _In_ const UNICODE_STRING* registryPath,
    _Out_ WDFDRIVER* pDriver,
    _Out_ WDFDEVICE* pDevice
)
/**
初始化，创建wdf驱动
使用控制设备对象 - Windows drivers | Microsoft Docs
https://docs.microsoft.com/zh-cn/windows-hardware/drivers/wdf/using-control-device-objects
*/
{

	NTSTATUS Status;
	WDF_DRIVER_CONFIG config;
	PWDFDEVICE_INIT pDeviceInit = NULL;

	WDF_FILEOBJECT_CONFIG fileConfie;
	WDF_IO_QUEUE_CONFIG ioConfig;
	WDFQUEUE queue;

	UNICODE_STRING ntDeviceName;
	UNICODE_STRING symbolicName;

	//初始化WDF驱动配置
	//对结构体清0 第二个参数为AddDevice
	WDF_DRIVER_CONFIG_INIT(&config, WDF_NO_EVENT_CALLBACK);

	//非Pnp驱动
	config.DriverInitFlags  |= WdfDriverInitNonPnpDriver;
	//配置卸载函数
	config.EvtDriverUnload = Capture2DriverUnload; //卸载函数

	//创建一个framework的驱动对象
	//为驱动创建WDF框架 最后一个参数为out_opt 指向新创建的WDF驱动框架指针
	Status = WdfDriverCreate(
	             driverObject,
	             registryPath,
	             WDF_NO_OBJECT_ATTRIBUTES,
	             &config,
	             pDriver
	         );

	if (!NT_SUCCESS(Status))
	{
		DbgPrint("WdfDriverCreate 驱动框架创建失败！Status:%X\n",Status);
		return STATUS_UNSUCCESSFUL;
	}

	//创建一个设备
	//分配一块内存
	pDeviceInit = WdfControlDeviceInitAllocate(*pDriver, &SDDL_DEVOBJ_SYS_ALL_ADM_ALL);
	
	WdfDeviceInitSetDeviceType(pDeviceInit, FILE_DEVICE_NETWORK);
	WdfDeviceInitSetCharacteristics(pDeviceInit, FILE_DEVICE_SECURE_OPEN, FALSE);
	WdfDeviceInitSetCharacteristics(pDeviceInit, FILE_AUTOGENERATED_DEVICE_NAME, TRUE);

	//内核可访问，用户态不可访问的名字
	//为设备分配名字
	//在NT驱动中是在创建设备时指定的 而在WDF驱动中,把设备名放在了WDFDEVICE_INIT结构体中
	//DECLARE_CONST_UNICODE_STRING
	RtlInitUnicodeString(&ntDeviceName, CAPTURE2_DEVICE_NAME);
	Status = WdfDeviceInitAssignName(
	             pDeviceInit,
	             &ntDeviceName
	         );

	if (!NT_SUCCESS(Status))
	{
		DbgPrint("WdfDeviceInitAssignName failed! Status:%X\n",Status);
		return Status;
	}

	//指定事件处理回调函数
	WDF_FILEOBJECT_CONFIG_INIT(&fileConfie, EvFileCreate, EvFileClose, EvFileCleanup);
	//注册事件回调函数，并为驱动程序的框架文件对象设置配置信息。
	WdfDeviceInitSetFileObjectConfig(pDeviceInit, &fileConfie, WDF_NO_OBJECT_ATTRIBUTES);

	//创建设备对象 第三个参数就是返回的设备对象
	//创建一个wdf设备
	// If WdfDeviceCreate was successful, it will set pDeviceInit to NULL.
	Status = WdfDeviceCreate(&pDeviceInit, WDF_NO_OBJECT_ATTRIBUTES, pDevice);

	//创建设备失败
	if(pDeviceInit) {
		DbgPrint("WdfDeviceCreate failed! Status:%X\n",Status);
		return Status;
	}

	/*I/O队列操作*/
	//初始化IO队列
	WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioConfig, WdfIoQueueDispatchSequential);
	//指定设备控制函数
	//设置处理IRP IRP_MJ_CONTROL的函数
	ioConfig.EvtIoDeviceControl = Capture2EvtIoDeviceControl;

	//创建IO队列
	Status = WdfIoQueueCreate(*pDevice, &ioConfig, WDF_NO_OBJECT_ATTRIBUTES, &queue);

	if (!NT_SUCCESS(Status))
	{
		DbgPrint("WdfIoQueueCreate failed! Status:%X\n",Status);
		return Status;
	}

	//创建符号链接
	RtlInitUnicodeString(&symbolicName, CAPTURE2_SYMBOLIC_NAME);
	Status = WdfDeviceCreateSymbolicLink(*pDevice, &symbolicName);

	if (!NT_SUCCESS(Status))
	{
		DbgPrint("符号链接创建失败。Status：%d\n",Status);
	}

	//完成创建
	WdfControlFinishInitializing(*pDevice);

	if (!NT_SUCCESS(Status))
	{
		if (pDeviceInit) {
			WdfDeviceInitFree(pDeviceInit);
		}

	}

	return Status;
}


/*
初始化Globals变量
*/
VOID
InitGlobals(){
	
	Globals.MacDebug = 0;
	Globals.record = 0;
	Globals.ipBlock = 1;
	
	//初始化链表
	InitializeListHead(& (Globals.mac_list_head) );
	//初始化锁
	KeInitializeSpinLock(& (Globals.spin_lock) );
	//初始化链表
	InitializeListHead(& (Globals.record_list_head) );
	//初始化锁
	KeInitializeSpinLock(& (Globals.record_spin_lock) );
	//初始化链表
	InitializeListHead(& (Globals.rule_list_head) );
	//初始化锁
	KeInitializeSpinLock(& (Globals.rule_spin_lock) );

	/*
	PCapture2_IPBLOCK pIpblock;
	pIpblock = ExAllocatePoolWithTag(NonPagedPool,sizeof(Capture2_IPBLOCK),'rule');

	RtlZeroMemory(pIpblock, sizeof(Capture2_IPBLOCK));
	pIpblock->id           = 1;
	pIpblock->protocol     = 6;
	pIpblock->direction    = 1;              //0入站，1出站，2双向，3其他
	pIpblock->srcIp        = 0x00000000;
	pIpblock->srcIpMask    = 0x00000000;
	pIpblock->srcPort      = 0x0000;
	pIpblock->dstIp        = 0x00000000; 
	pIpblock->dstIpMask    = 0x00000000;
	pIpblock->dstPort      = 0x1F90;         //8080端口
	
	ExInterlockedInsertTailList( &(Globals.rule_list_head),&(pIpblock->ListEntry),&(Globals.rule_spin_lock) );
	*/
}



NTSTATUS
DriverEntry(
    _In_ DRIVER_OBJECT* DriverObject,
    _In_ UNICODE_STRING* RegistryPath
)
/*
    驱动入口
*/
{
	DbgPrint("DriverEntry");
	NTSTATUS Status;
	WDFDEVICE WdfDevice;
	WDFDRIVER WdfDriver;

	//
	// 初始化全局变量结构体
	RtlZeroMemory(&Globals, sizeof(Globals));
	InitGlobals();

	Status = Capture2InitDriver(
	             DriverObject,
	             RegistryPath,
	             &WdfDriver,
	             &WdfDevice);

	Globals.WdmDevice = WdfDeviceWdmGetDeviceObject(WdfDevice);

	if (!NT_SUCCESS(Status))
	{
		DbgPrint("WdfDeviceWdmGetDeviceObject failed. Status：%d\n",Status);
		return Status;
	}

	Status = Capture2RegisterCallouts(Globals.WdmDevice);

	if (!NT_SUCCESS(Status))
	{
		DbgPrint("Capture2RegisterCallouts failed. Status：%d\n",Status);
		return Status;
	}

	return Status;

}

